<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>证明策略 - Lean中文教程</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title_page.html">Lean 4定理证明</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.1.</strong> 安装</a></li></ol></li><li class="chapter-item expanded "><a href="dependent_type_theory.html"><strong aria-hidden="true">2.</strong> 依值类型论</a></li><li class="chapter-item expanded "><a href="propositions_and_proofs.html"><strong aria-hidden="true">3.</strong> 命题和证明</a></li><li class="chapter-item expanded "><a href="quantifiers_and_equality.html"><strong aria-hidden="true">4.</strong> 量词与等价</a></li><li class="chapter-item expanded "><a href="tactics.html" class="active"><strong aria-hidden="true">5.</strong> 证明策略</a></li><li class="chapter-item expanded "><a href="interacting_with_lean.html"><strong aria-hidden="true">6.</strong> 使用Lean进行工作</a></li><li class="chapter-item expanded "><a href="inductive_types.html"><strong aria-hidden="true">7.</strong> 归纳类型</a></li><li class="chapter-item expanded "><a href="induction_and_recursion.html"><strong aria-hidden="true">8.</strong> Induction and Recursion</a></li><li class="chapter-item expanded "><a href="structures_and_records.html"><strong aria-hidden="true">9.</strong> 结构体和记录</a></li><li class="chapter-item expanded "><a href="type_classes.html"><strong aria-hidden="true">10.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="conv.html"><strong aria-hidden="true">11.</strong> 转换策略模式</a></li><li class="chapter-item expanded "><a href="axioms_and_computation.html"><strong aria-hidden="true">12.</strong> Axioms and Computation</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">13.</strong> 术语表</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lean中文教程</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/subfish-zhou/theorem_proving_in_lean4_zh_CN" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="证明策略"><a class="header" href="#证明策略">证明策略</a></h1>
<p>在本章中，我们描述了另一种构建证明的方法，即使用<em>策略</em>（tactics）。 一个证明项代表一个数学证明；策略是描述如何建立这样一个证明的命令或指令。你可以在数学证明开始时非正式地说：“为了证明条件的必要性，展开定义，应用前面的定理，并进行简化。”就像这些指令告诉读者如何构建证明一样，策略告诉Lean如何构建证明。它们自然而然地支持增量式的证明书写，在这种写作方式中，你将分解一个证明，并一步步地实现目标。</p>
<p>我们将把由策略序列组成的证明描述为“策略式”证明，以便与我们迄今为止所看到的写证明的方式进行对比，我们将其称为“项式”证明。每种风格都有自己的优点和缺点。例如，策略式证明可能更难读，因为它们要求读者预测或猜测每条指令的结果。但它们一般更短，更容易写。此外，策略提供了一个使用Lean自动化的途径，因为自动化程序本身就是策略。</p>
<h2 id="进入策略模式"><a class="header" href="#进入策略模式">进入策略模式</a></h2>
<p>从概念上讲，陈述一个定理或引入一个<code>have</code>的声明会产生一个目标，即构造一个具有预期类型的项的目标。例如, 下面创建的目标是构建一个类型为<code>p ∧ q ∧ p</code>的项，条件有常量<code>p q : Prop</code>，<code>hp : p</code>和<code>hq : q</code>。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  sorry
</code></pre>
<p>写成目标如下：</p>
<pre><code>    p : Prop, q : Prop, hp : p, hq : q ⊢ p ∧ q ∧ p
</code></pre>
<p>事实上，如果你把上面的例子中的“sorry”换成下划线，Lean会报告说，正是这个目标没有得到解决。</p>
<p>通常情况下，你会通过写一个明确的项来满足这样的目标。但在任何需要项的地方，Lean允许我们插入一个<code>by &lt;tactics&gt;</code>块，其中<code>&lt;tactics&gt;</code>是一串命令，用分号或换行符分开。你可以用下面这种方式来证明上面的定理：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
  by apply And.intro
     exact hp
     apply And.intro
     exact hq
     exact hp
</code></pre>
<p>我们经常将<code>by</code>关键字放在前一行，并将上面的例子写为</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  exact hp
  apply And.intro
  exact hq
  exact hp
</code></pre>
<p><code>apply</code>策略应用于一个表达式，被视为表示一个有零或多个参数的函数。它将结论与当前目标中的表达式统一起来，并为剩余的参数创建新的目标，只要后面的参数不依赖于它们。在上面的例子中，命令<code>apply And.intro</code>产生了两个子目标：</p>
<pre><code>    case left
    p : Prop,
    q : Prop,
    hp : p,
    hq : q
    ⊢ p

    case right
    p : Prop,
    q : Prop,
    hp : p,
    hq : q
    ⊢ q ∧ p
</code></pre>
<p>第一个目标是通过<code>exact hp</code>命令来实现的。<code>exact</code>命令只是<code>apply</code>的一个变体，它表示所给的表达式应该准确地填充目标。在策略证明中使用它很有益，因为它如果失败那么表明出了问题。它也比<code>apply</code>更稳健，因为繁饰器在处理被应用的表达式时，会考虑到目标所预期的类型。然而，在这种情况下，<code>apply</code>也可以很好地工作。</p>
<p>你可以用<code>#print</code>命令查看所产生的证明项。</p>
<pre><code class="language-lean"># theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
#  apply And.intro
#  exact hp
#  apply And.intro
#  exact hq
#  exact hp
#print test
</code></pre>
<p>你可以循序渐进地写一个策略脚本。在VS Code中，你可以通过按<code>Ctrl-Shift-Enter</code>打开一个窗口来显示信息，然后只要光标在策略块中，该窗口就会显示当前的目标。在Emacs中，你可以通过按<code>C-c C-g</code>看到任何一行末尾的目标，或者通过把光标放在最后一个策略的第一个字符之后，看到一个不完整的证明中的剩余目标。如果证明是不完整的，标记<code>by</code>会被装饰成一条红色的斜线，错误信息中包含剩余的目标。</p>
<p>策略命令可以接受复合表达式，而不仅仅是单一标识符。下面是前面证明的一个简短版本。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp
  exact And.intro hq hp
#print test
</code></pre>
<p>多个策略应用可以通过用分号连接写在一行中。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro hp; exact And.intro hq hp
</code></pre>
<p>可能产生多个子目标的策略通常对子目标进行标记。例如，<code>apply And.intro</code>策略将第一个目标标记为<code>left</code>，将第二个目标标记为<code>right</code>。在<code>apply</code>策略的情况下，标签是从<code>And.intro</code>声明中使用的参数名称推断出来的。你可以使用符号<code>case &lt;tag&gt; =&gt; &lt;tactics&gt;</code>来结构化你的策略。下面是本章中第一个策略证明的结构化版本。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case left =&gt; exact hp
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
</code></pre>
<p>使用<code>case</code>标记，你也可以在<code>left</code>之前先解决子目标<code>right</code>：</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  case right =&gt;
    apply And.intro
    case left =&gt; exact hq
    case right =&gt; exact hp
  case left =&gt; exact hp
</code></pre>
<p>注意，Lean将其他目标隐藏在<code>case</code>块内。我们说它“专注”于选定的目标。 此外，如果所选目标在<code>case</code>块的末尾没有完全解决，Lean会标记一个错误。</p>
<p>对于简单的子目标，可能不值得使用其标签来选择一个子目标，但你可能仍然想要结构化证明。Lean还提供了“子弹”符号<code>. &lt;tactics&gt;</code>或<code>· &lt;tactics&gt;</code>。</p>
<pre><code class="language-lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by
  apply And.intro
  . exact hp
  . apply And.intro
    . exact hq
    . exact hp
</code></pre>
<h2 id="基本策略"><a class="header" href="#基本策略">基本策略</a></h2>
<p>除了<code>apply</code>和<code>exact</code>之外，另一个有用的策略是<code>intro</code>，它引入了一个假设。下面是我们在前一章中证明的命题逻辑中的一个等价性的例子，现在用策略来证明。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    apply Or.elim (And.right h)
    . intro hq
      apply Or.inl
      apply And.intro
      . exact And.left h
      . exact hq
    . intro hr
      apply Or.inr
      apply And.intro
      . exact And.left h
      . exact hr
  . intro h
    apply Or.elim h
    . intro hpq
      apply And.intro
      . exact And.left hpq
      . apply Or.inl
        exact And.right hpq
    . intro hpr
      apply And.intro
      . exact And.left hpr
      . apply Or.inr
        exact And.right hpr
</code></pre>
<p><code>intro</code>命令可以更普遍地用于引入任何类型的变量。</p>
<pre><code class="language-lean">example (α : Type) : α → α := by
  intro a
  exact a

example (α : Type) : ∀ x : α, x = x := by
  intro x
  exact Eq.refl x
</code></pre>
<p>你可以同时引入好几个变量：</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intro a b c h₁ h₂
  exact Eq.trans (Eq.symm h₂) h₁
</code></pre>
<p>由于<code>apply</code>策略是一个用于交互式构造函数应用的命令，<code>intro</code>策略是一个用于交互式构造函数抽象的命令（即<code>fun x =&gt; e</code>形式的项）。 与lambda抽象符号一样，<code>intro</code>策略允许我们使用隐式的<code>match</code>。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro ⟨w, hpw, hqw⟩
  exact ⟨w, hqw, hpw⟩
</code></pre>
<p>就像<code>match</code>表达式一样，你也可以提供多个选项。</p>
<pre><code class="language-lean">example (α : Type) (p q : α → Prop) : (∃ x, p x ∨ q x) → ∃ x, q x ∨ p x := by
  intro
    | ⟨w, Or.inl h⟩ =&gt; exact ⟨w, Or.inr h⟩
    | ⟨w, Or.inr h⟩ =&gt; exact ⟨w, Or.inl h⟩
</code></pre>
<p><code>intros</code>策略可以在没有任何参数的情况下使用，在这种情况下，它选择名字并尽可能多地引入变量。稍后你会看到一个例子。</p>
<p><code>assumption</code>策略在当前目标的背景下查看假设，如果有一个与结论相匹配的假设，它就会应用这个假设。</p>
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  assumption   -- applied h₃
</code></pre>
<p>若有必要，它会在结论中统一元变量。</p>
<pre><code class="language-lean">example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans
  assumption      -- solves x = ?b with h₁
  apply Eq.trans
  assumption      -- solves y = ?h₂.b with h₂
  assumption      -- solves z = w with h₃
</code></pre>
<p>下面的例子使用<code>intros</code>命令来自动引入三个变量和两个假设：</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption
</code></pre>
<p>请注意，由Lean自动生成的名称在默认情况下是不可访问的。其动机是为了确保你的策略证明不依赖于自动生成的名字，并因此而更加强大。然而，你可以使用组合子<code>unhygienic</code>来禁用这一限制。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by unhygienic
  intros
  apply Eq.trans
  apply Eq.symm
  exact a_2
  exact a_1
</code></pre>
<p>你也可以使用<code>rename_i</code>策略来重命名你的上下文中最近的不能访问的名字。在下面的例子中，策略<code>rename_i h1 _ h2</code>在你的上下文中重命名了三个假设中的两个。</p>
<pre><code class="language-lean">example : ∀ a b c d : Nat, a = b → a = d → a = c → c = b := by
  intros
  rename_i h1 _ h2
  apply Eq.trans
  apply Eq.symm
  exact h2
  exact h1
</code></pre>
<p><code>rfl</code>策略是<code>exact rfl</code>的语法糖。</p>
<pre><code class="language-lean">example (y : Nat) : (fun x : Nat =&gt; 0) y = 0 :=
  by rfl
</code></pre>
<p><code>repeat</code>组合子可以多次使用一个策略。</p>
<pre><code class="language-lean">example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  repeat assumption
</code></pre>
<p>另一个有时很有用的策略是还原<code>revert</code>策略，从某种意义上说，它是对<code>intro</code>的逆。</p>
<pre><code class="language-lean">example (x : Nat) : x = x := by
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<p>将一个假设还原到目标中会产生一个蕴含。</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert h
  -- goal is x y : Nat ⊢ x = y → y = x
  intro h₁
  -- goal is x y : ℕ, h₁ : x = y ⊢ y = x
  apply Eq.symm
  assumption
</code></pre>
<p>但是<code>revert</code>更聪明，因为它不仅会还原上下文中的一个元素，还会还原上下文中所有依赖它的后续元素。例如，在上面的例子中，还原<code>x</code>会带来<code>h</code>。</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x
  -- goal is y : Nat ⊢ ∀ (x : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<p>你还可以一次性还原多个元素：</p>
<pre><code class="language-lean">example (x y : Nat) (h : x = y) : y = x := by
  revert x y
  -- goal is ⊢ ∀ (x y : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption
</code></pre>
<p>你只能<code>revert</code>局部环境中的一个元素，也就是一个局部变量或假设。但是你可以使用泛化<code>generalize</code>策略将目标中的任意表达式替换为新的变量。</p>
<pre><code class="language-lean">example : 3 = 3 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ x = x,
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl
</code></pre>
<p>上述符号的记忆法是，你通过将<code>3</code>设定为任意变量<code>x</code>来泛化目标。要注意：不是每一个泛化都能保留目标的有效性。这里，<code>generalize</code>用一个无法证明的目标取代了一个可以用<code>rfl</code>证明的目标。</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize  3 = x
  -- goal is x : Nat ⊢ 2 + x = 5
  admit
</code></pre>
<p>在这个例子中，<code>admit</code>策略是<code>sorry</code>证明项的类似物。它关闭了当前的目标，产生了通常的警告：使用了<code>sorry</code>。为了保持之前目标的有效性，<code>generalize</code>策略允许我们记录<code>3</code>已经被<code>x</code>所取代的事实。你所需要做的就是提供一个标签，<code>generalize</code>使用它来存储局部上下文中的赋值。</p>
<pre><code class="language-lean">example : 2 + 3 = 5 := by
  generalize h : 3 = x
  -- goal is x : Nat, h : 3 = x ⊢ 2 + x = 5
  rw [← h]
</code></pre>
<p>这里<code>rewrite</code>策略，缩写为<code>rw</code>，用<code>h</code>把<code>x</code>用<code>3</code>换了回来。<code>rewrite</code>策略下文将继续讨论。</p>
<h2 id="更多策略"><a class="header" href="#更多策略">更多策略</a></h2>
<p>一些额外的策略对于建构和析构命题以及数据很有用。例如，当应用于形式为<code>p ∨ q</code>的目标时，你可以使用<code>apply Or.inl</code>和<code>apply Or.inr</code>等策略。 反之，<code>cases</code>策略可以用来分解一个析取。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inl hp =&gt; apply Or.inr; exact hp
  | inr hq =&gt; apply Or.inl; exact hq
</code></pre>
<p>注意，该语法与<code>match</code>表达式中使用的语法相似。新的子目标可以按任何顺序解决。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inr hq =&gt; apply Or.inl; exact hq
  | inl hp =&gt; apply Or.inr; exact hp
</code></pre>
<p>你也可以使用一个（非结构化的）<code>cases</code>，而不使用<code>with</code>，并为每个备选情况制定一个策略。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  apply Or.inr
  assumption
  apply Or.inl
  assumption
</code></pre>
<p>（非结构化的）<code>cases</code>在你可以用同一个策略来解决子任务时格外有用。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h
  repeat assumption
</code></pre>
<p>你也可以使用组合子<code>tac1 &lt;;&gt; tac2</code>，将<code>tac2</code>应用于策略<code>tac1</code>产生的每个子目标。</p>
<pre><code class="language-lean">example (p : Prop) : p ∨ p → p := by
  intro h
  cases h &lt;;&gt; assumption
</code></pre>
<p>你可以与<code>.</code>符号相结合使用非结构化的<code>cases</code>策略。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  . apply Or.inr
    assumption
  . apply Or.inl
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  case inl h =&gt;
    apply Or.inr
    assumption

example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr h =&gt;
    apply Or.inl
    assumption
  . apply Or.inr
    assumption
</code></pre>
<p><code>cases</code>策略也被用来分解一个析取。</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ q → q ∧ p := by
  intro h
  cases h with
  | intro hp hq =&gt; constructor; exact hq; exact hp
</code></pre>
<p>在这个例子中，应用<code>cases</code>策略后只有一个目标，<code>h : p ∧ q</code>被一对假设取代，<code>hp : p</code>和<code>hq : q</code>。<code>constructor</code>策略应用了唯一一个合取构造子<code>And.intro</code>。有了这些策略，上一节的一个例子可以改写如下。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h with
    | intro hp hqr =&gt;
      cases hqr
      . apply Or.inl; constructor &lt;;&gt; assumption
      . apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    cases h with
    | inl hpq =&gt;
      cases hpq with
      | intro hp hq =&gt; constructor; exact hp; apply Or.inl; exact hq
    | inr hpr =&gt;
      cases hpr with
      | intro hp hr =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<!-- <<<<<<< HEAD -->
<p>你将在<a href="./inductive_types.html">归纳类型</a>一章中看到，这些策略是相当通用的。<code>cases</code>策略可以用来分解递归定义类型的任何元素；<code>constructor</code>总是应用递归定义类型的第一个适用构造子。例如，你可以使用<code>cases</code>和<code>constructor</code>与一个存在量词：</p>
<!-- ======= -->
<!-- 你将在[递归类型](./inductive_types.md)一章中看到，这些策略是相当通用的。``cases``策略可以用来分解递归定义类型的任何元素；``constructor``总是应用递归定义类型的第一个适用构造子。例如，你可以使用``cases``和``constructor``与一个存在量词： -->
<!-- >>>>>>> 9647471447f08eb78a8c7dde28bf1857dae49c9f -->
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; constructor; apply Or.inl; exact px
</code></pre>
<p>在这里，<code>constructor</code>策略将存在性断言的第一个组成部分，即<code>x</code>的值，保留为隐式的。它是由一个元变量表示的，这个元变量以后应该被实例化。在前面的例子中，元变量的正确值是由策略<code>exact px</code>决定的，因为<code>px</code>的类型是<code>p x</code>。如果你想明确指定存在量词的存在者，你可以使用<code>exists</code>策略来代替。</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  cases h with
  | intro x px =&gt; exists x; apply Or.inl; exact px
</code></pre>
<p>另一个例子：</p>
<pre><code class="language-lean">example (p q : Nat → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro h
  cases h with
  | intro x hpq =&gt;
    cases hpq with
    | intro hp hq =&gt;
      exists x
      constructor &lt;;&gt; assumption
</code></pre>
<p>这些策略既可以用在命题上，也可以用在数上。在下面的两个例子中，它们被用来定义交换乘法和加法类型组件的函数：</p>
<pre><code class="language-lean">def swap_pair : α × β → β × α := by
  intro p
  cases p
  constructor &lt;;&gt; assumption
</code></pre>
<pre><code class="language-lean">def swap_sum : Sum α β → Sum β α := by
  intro p
  cases p
  . apply Sum.inr; assumption
  . apply Sum.inl; assumption
</code></pre>
<p>在我们为变量选择的名称之前，它们的定义与有关合取和析取的类似命题的证明是相同的。<code>cases</code>策略也会对自然数进行逐情况区分：</p>
<p>除了我们为变量选择的名称外，这些定义与合取和析取的类似命题的证明是相同的。<code>cases</code>策略也会在自然数上区分情况：</p>
<pre><code class="language-lean">open Nat
example (P : Nat → Prop) (h₀ : P 0) (h₁ : ∀ n, P (succ n)) (m : Nat) : P m := by
 cases m with
 | zero    =&gt; exact h₀
 | succ m' =&gt; exact h₁ m'
</code></pre>
<p><code>cases</code>策略伙同<code>induction</code>策略将在<a href="./inductive_types.html#_tactics_for_inductive_types">归纳类型的策略</a>一节中详述。</p>
<p><code>contradiction</code>策略搜索当前目标的假设中的矛盾：</p>
<pre><code class="language-lean">example (p q : Prop) : p ∧ ¬ p → q := by
  intro h
  cases h
  contradiction
</code></pre>
<p>你也可以在策略块中使用<code>match</code>：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    match h with
    | ⟨_, Or.inl _⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
    | ⟨_, Or.inr _⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro h
    match h with
    | Or.inl ⟨hp, hq⟩ =&gt; constructor; exact hp; apply Or.inl; exact hq
    | Or.inr ⟨hp, hr⟩ =&gt; constructor; exact hp; apply Or.inr; exact hr
</code></pre>
<p>你可以将<code>intro h</code>与<code>match h ...</code>结合起来，然后上例就可以如下地写出：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro
     | ⟨hp, Or.inl hq⟩ =&gt; apply Or.inl; constructor &lt;;&gt; assumption
     | ⟨hp, Or.inr hr⟩ =&gt; apply Or.inr; constructor &lt;;&gt; assumption
  . intro
     | Or.inl ⟨hp, hq⟩ =&gt; constructor; assumption; apply Or.inl; assumption
     | Or.inr ⟨hp, hr⟩ =&gt; constructor; assumption; apply Or.inr; assumption

</code></pre>
<h2 id="结构化策略证明"><a class="header" href="#结构化策略证明">结构化策略证明</a></h2>
<p>策略通常提供了建立证明的有效方法，但一长串指令会掩盖论证的结构。在这一节中，我们将描述一些有助于为策略式证明提供结构的方法，使这种证明更易读，更稳健。</p>
<p>Lean的证明写作语法的一个优点是，它可以混合项式和策略式证明，并在两者之间自由转换。例如，策略<code>apply</code>和<code>exact</code>可以传入任意的项，你可以用<code>have</code>，<code>show</code>等等来写这些项。反之，当写一个任意的Lean项时，你总是可以通过插入一个<code>by</code>块来调用策略模式。下面是一个简易例子：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro h
  exact
    have hp : p := h.left
    have hqr : q ∨ r := h.right
    show (p ∧ q) ∨ (p ∧ r) by
      cases hqr with
      | inl hq =&gt; exact Or.inl ⟨hp, hq⟩
      | inr hr =&gt; exact Or.inr ⟨hp, hr⟩
</code></pre>
<p>更自然一点：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt; exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt; exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt; exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt; exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<p>事实上，有一个<code>show</code>策略，它类似于证明项中的<code>show</code>表达式。它只是简单地声明即将被解决的目标的类型，同时保持策略模式。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  . intro h
    cases h.right with
    | inl hq =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inl ⟨h.left, hq⟩
    | inr hr =&gt;
      show (p ∧ q) ∨ (p ∧ r)
      exact Or.inr ⟨h.left, hr⟩
  . intro h
    cases h with
    | inl hpq =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt;
      show p ∧ (q ∨ r)
      exact ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<p><code>show</code>策略其实可以被用来重写一些定义等价的目标：</p>
<pre><code class="language-lean">example (n : Nat) : n + 1 = Nat.succ n := by
  show Nat.succ n = Nat.succ n
  rfl
</code></pre>
<p>还有一个<code>have</code>策略，它引入了一个新的子目标，就像写证明项时一样。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have hpq : p ∧ q := And.intro hp hq
    apply Or.inl
    exact hpq
  | inr hr =&gt;
    have hpr : p ∧ r := And.intro hp hr
    apply Or.inr
    exact hpr
</code></pre>
<p>与证明项一样，你可以省略<code>have</code>策略中的标签，在这种情况下，将使用默认标签<code>this</code>：</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  show (p ∧ q) ∨ (p ∧ r)
  cases hqr with
  | inl hq =&gt;
    have : p ∧ q := And.intro hp hq
    apply Or.inl
    exact this
  | inr hr =&gt;
    have : p ∧ r := And.intro hp hr
    apply Or.inr
    exact this
</code></pre>
<p><code>have</code>策略中的类型可以省略，所以你可以写<code>have hp := h.left</code>和<code>have hqr := h.right</code>。 事实上，使用这种符号，你甚至可以省略类型和标签，在这种情况下，新的事实是用标签<code>this</code>引入的。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro ⟨hp, hqr⟩
  cases hqr with
  | inl hq =&gt;
    have := And.intro hp hq
    apply Or.inl; exact this
  | inr hr =&gt;
    have := And.intro hp hr
    apply Or.inr; exact this
</code></pre>
<p>Lean还有一个<code>let</code>策略，与<code>have</code>策略类似，但用于引入局部定义而不是辅助事实。它是证明项中<code>let</code>的策略版。</p>
<pre><code class="language-lean">example : ∃ x, x + 2 = 8 := by
  let a : Nat := 3 * 2
  exists a
  rfl
</code></pre>
<p>和<code>have</code>一样，你可以通过写<code>let a := 3 * 2</code>来保留类型为隐式。<code>let</code>和<code>have</code>的区别在于，<code>let</code>在上下文中引入了一个局部定义，因此局部声明的定义可以在证明中展开。</p>
<p>我们使用了<code>.</code>来创建嵌套的策略块。 在一个嵌套块中，Lean专注于第一个目标，如果在该块结束时还没有完全解决，就会产生一个错误。这对于表明一个策略所引入的多个子目标的单独证明是有帮助的。符号<code>.</code>是对空格敏感的，并且依靠缩进来检测策略块是否结束。另外，你也可以用大括号和分号来定义策略块。</p>
<pre><code class="language-lean">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro
  { intro h;
    cases h.right;
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inl ⟨h.left, ‹q›⟩ }
    { show (p ∧ q) ∨ (p ∧ r);
      exact Or.inr ⟨h.left, ‹r›⟩ } }
  { intro h;
    cases h;
    { show p ∧ (q ∨ r);
      rename_i hpq;
      exact ⟨hpq.left, Or.inl hpq.right⟩ }
    { show p ∧ (q ∨ r);
      rename_i hpr;
      exact ⟨hpr.left, Or.inr hpr.right⟩ } }
</code></pre>
<p>使用缩进来构造证明很有用：每次一个策略留下一个以上的子目标时，我们通过将它们封装在块中并缩进来分隔剩下的子目标。因此，如果将定理<code>foo</code>应用于一个目标产生了四个子目标，那么我们就可以期待这样的证明：</p>
<pre><code>  apply foo
  . &lt;proof of first goal&gt;
  . &lt;proof of second goal&gt;
  . &lt;proof of third goal&gt;
  . &lt;proof of final goal&gt;
</code></pre>
<p>或</p>
<pre><code>  apply foo
  case &lt;tag of first goal&gt;  =&gt; &lt;proof of first goal&gt;
  case &lt;tag of second goal&gt; =&gt; &lt;proof of second goal&gt;
  case &lt;tag of third goal&gt;  =&gt; &lt;proof of third goal&gt;
  case &lt;tag of final goal&gt;  =&gt; &lt;proof of final goal&gt;
</code></pre>
<p>或</p>
<pre><code>  apply foo
  { &lt;proof of first goal&gt;  }
  { &lt;proof of second goal&gt; }
  { &lt;proof of third goal&gt;  }
  { &lt;proof of final goal&gt;  }
</code></pre>
<h2 id="策略组合子"><a class="header" href="#策略组合子">策略组合子</a></h2>
<p><em>策略组合子</em>是由旧策略形成新策略的操作。序列组合子已经隐含在<code>by</code>块中：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q :=
  by apply Or.inl; assumption
</code></pre>
<p>这里，<code>apply Or.inl; assumption</code>在功能上等同于一个单独的策略，它首先应用<code>apply Or.inl</code>，然后应用<code>assumption</code>。</p>
<p>在<code>t₁ &lt;;&gt; t₂</code>中，<code>&lt;;&gt;</code>操作符提供了一个<em>并行</em>的序列操作。<code>t₁</code>被应用于当前目标，然后<code>t₂</code>被应用于<em>所有</em>产生的子目标：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) (hq : q) : p ∧ q :=
  by constructor &lt;;&gt; assumption
</code></pre>
<p>当所产生的目标能够以统一的方式完成时，或者，至少，当有可能以统一的方式在所有的目标上取得进展时，这就特别有用。</p>
<p><code>first | t₁ | t₂ | ... | tₙ</code>应用每个<code>tᵢ</code>，直到其中一个成功，否则就失败：</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∨ q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption

--译者注：原文看上去少了一个例子，译者据文意补全了。
example (p q : Prop) (hq : q) : p ∨ q := by --(hq : q)条件变化了。
  first | apply Or.inl; assumption | apply Or.inr; assumption
</code></pre>
<p>在第一个例子中，左分支成功了，而在第二个例子中，右分支成功了。在接下来的三个例子中，同样的复合策略在每种情况下都能成功。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hq : q) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hr : r) : p ∨ q ∨ r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)
</code></pre>
<p>该策略试图通过假设立即解决左边的析取项；如果失败，它就试图关注右边的析取项；如果不成功，它就调用假设策略。</p>
<p>毫无疑问，策略可能会失败。事实上，正是这种“失败”状态导致<em>第一</em>组合子回溯并尝试下一个策略。<code>try</code>组合子建立了一个总是成功的策略，尽管可能是以一种平凡的方式：<code>try t</code>执行<code>t</code>并报告成功，即使<code>t</code>失败。它等同于<code>first | t | skip</code>，其中<code>skip</code>是一个什么都不做的策略（并且成功地做到了）。在下一个例子中，第二个<code>constructor</code>在右边的合取项<code>q ∧ r</code>上成功了（注意，合取和析取是右结合的），但在第一个合取项上失败。<code>try</code>策略保证了序列组合的成功。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor &lt;;&gt; (try constructor) &lt;;&gt; assumption
</code></pre>
<p>小心：<code>repeat (try t)</code>将永远循环，因为内部策略永远不会失败。</p>
<p>在一个证明中，往往有多个目标未完成。并行序列是一种布置方式，以便将一个策略应用于多个目标，但也有其他的方式可以做到这一点。例如，<code>all_goals t</code>将<code>t</code>应用于所有未完成的目标：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  all_goals (try constructor)
  all_goals assumption
</code></pre>
<p>在这种情况下，<code>any_goals</code>策略提供了一个更稳健的解决方案。它与<code>all_goals</code>类似，只是除非它的参数至少在一个目标上成功，否则就会失败。</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by
  constructor
  any_goals constructor
  any_goals assumption
</code></pre>
<p>下面<code>by</code>块中的第一个策略是反复拆分合取：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals constructor)
  all_goals assumption
</code></pre>
<p>其实可以将整个策略压缩成一行：</p>
<pre><code class="language-lean">example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := by
  repeat (any_goals (first | constructor | assumption))
</code></pre>
<p>组合子<code>focus t</code>确保<code>t</code>只影响当前的目标，暂时将其他目标从作用范围中隐藏。因此，如果<code>t</code>通常只影响当前目标，<code>focus (all_goals t)</code>与<code>t</code>具有相同的效果。</p>
<h2 id="重写"><a class="header" href="#重写">重写</a></h2>
<p>在<a href="./quantifiers_and_equality.html#%E8%AE%A1%E7%AE%97%E5%BC%8F%E8%AF%81%E6%98%8E">计算式证明</a>一节中简要介绍了<code>rewrite</code>策略（简称<code>rw</code>）和 <code>simp</code>策略。在本节和下一节中，我们将更详细地讨论它们。</p>
<p><code>rewrite</code>策略提供了一种基本的机制，可以将替换应用于目标和假设，在处理等式时非常方便。该策略的最基本形式是<code>rewrite [t]</code>，其中<code>t</code>是一个类型断定为等式的项。例如，<code>t</code>可以是上下文中的一个假设<code>h : x = y</code>；可以是一个一般的法则，如<code>add_comm : ∀ x y, x + y = y + x</code>，在这个法则中，重写策略试图找到<code>x</code>和<code>y</code>的合适实例；或者可以是任何断言具体或一般等式的复合项。在下面的例子中，我们使用这种基本形式，用一个假设重写目标。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂] -- replace k with 0
  rw [h₁] -- replace f 0 with 0
</code></pre>
<p>在上面的例子中，第一次使用<code>rw</code>将目标<code>f k = 0</code>中的<code>k</code>替换成<code>0</code>。然后，第二次用<code>0</code>替换<code>f 0</code>。该策略自动关闭任何形式的目标<code>t = t</code>。下面是一个使用复合表达式进行重写的例子。</p>
<pre><code class="language-lean">example (x y : Nat) (p : Nat → Prop) (q : Prop) (h : q → x = y)
        (h' : p y) (hq : q) : p x := by
  rw [h hq]; assumption
</code></pre>
<p>这里，<code>h hq</code>建立了等式<code>x = y</code>。<code>h hq</code>周围的括号是不必要的，但为了清楚起见，还是加上了括号。</p>
<p>多个重写可以使用符号<code>rw [t_1, ..., t_n]</code>来组合，这只是<code>rw t_1; ...; rw t_n</code>的缩写。前面的例子可以写成如下：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  rw [h₂, h₁]
</code></pre>
<p>默认情况下，<code>rw</code>正向使用一个等式，用一个表达式匹配左边的等式，然后用右边的等式替换它。符号<code>←t</code>可以用来指示策略在反方向上使用等式<code>t</code>。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a b : Nat) (h₁ : a = b) (h₂ : f a = 0) : f b = 0 := by
  rw [←h₁, h₂]
</code></pre>
<p>在这个例子中，项<code>←h₁</code>指示重写器用<code>a</code>替换<code>b</code>。在编辑器中，你可以用<code>\l</code>输入反箭头。你也可以使用ascii替代品<code>&lt;-</code>。</p>
<p>有时一个等式的左侧可以匹配模式中的多个子项，在这种情况下，<code>rw</code>策略会在遍历项时选择它发现的第一个匹配。如果这不是你想要的，你可以使用附加参数来指定适当的子项。</p>
<pre><code class="language-lean">example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_comm b, ← Nat.add_assoc]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm b]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm _ b]
</code></pre>
<p>在上面的第一个例子中，第一步将<code>a + b + c</code>重写为<code>a + (b + c)</code>。然后，接下来对项<code>b + c</code>使用交换律；如果不指定参数，该策略将把<code>a + (b + c)</code>重写为<code>(b + c) + a</code>。最后一步以相反的方向应用结合律，将<code>a + (c + b)</code>改写为<code>a + c + b</code>。接下来的两个例子则是应用结合律将两边的小括号移到右边，然后将<code>b</code>和<code>c</code>调换。注意最后一个例子通过指定<code>Nat.add_comm</code>的第二个参数来指定重写应该在右侧进行。</p>
<p>默认情况下，<code>rewrite</code>策略只影响目标。符号<code>rw [t] at h</code>在假设<code>h</code>处应用重写<code>t</code>。</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a : Nat) (h : a + 0 = 0) : f a = f 0 := by
  rw [Nat.add_zero] at h
  rw [h]
</code></pre>
<p>第一步，<code>rw [Nat.add_zero] at h</code>将假设<code>a + 0 = 0</code>改写为<code>a = 0</code>。然后，新的假设<code>a = 0</code>被用来把目标重写为<code>f 0 = f 0</code>。</p>
<p><code>rewrite</code>策略不限于命题。在下面的例子中，我们用<code>rw [h] at t</code>来重写假设<code>t : Tuple α n</code>为<code>t : Tuple α 0</code>。</p>
<pre><code class="language-lean">def Tuple (α : Type) (n : Nat) :=
  { as : List α // as.length = n }

example (n : Nat) (h : n = 0) (t : Tuple α n) : Tuple α 0 := by
  rw [h] at t
  exact t
</code></pre>
<h2 id="简化"><a class="header" href="#简化">简化</a></h2>
<p><code>rewrite</code>被设计为操纵目标的手术工具，而简化器提供了一种更强大的自动化形式。Lean库中的一些特性已经被标记为<code>[simp]</code>属性，<code>simp</code>策略使用它们来反复重写表达式中的子项。</p>
<pre><code class="language-lean">example (x y z : Nat) (p : Nat → Prop) (h : p (x * y))
        : (x + 0) * (0 + y * 1 + z * 0) = x * y := by
  simp

example (x y z : Nat) (p : Nat → Prop) (h : p (x * y))
        : p ((x + 0) * (0 + y * 1 + z * 0)) := by
  simp; assumption
</code></pre>
<p>在第一个例子中，目标中等式的左侧被简化，使用涉及0和1的通常的同义词，将目标简化为<code>x * y = x * y'</code>。此时<code>simp'</code>应用反身性（rfl）来完成它。在第二个例子中，<code>simp</code>将目标化简为<code>p (x * y)</code>，这时假设<code>h</code>完成了它。下面是一些关于列表的例子。</p>
<pre><code class="language-lean">open List

example (xs : List Nat)
        : reverse (xs ++ [1, 2, 3]) = [3, 2, 1] ++ reverse xs := by
 simp

example (xs ys : List α)
        : length (reverse (xs ++ ys)) = length xs + length ys := by
 simp [Nat.add_comm]
</code></pre>
<p>就像<code>rw</code>，你也可以用关键字<code>at</code>来简化一个假设：</p>
<pre><code class="language-lean">example (x y z : Nat) (p : Nat → Prop)
        (h : p ((x + 0) * (0 + y * 1 + z * 0))) : p (x * y) := by
  simp at h; assumption
</code></pre>
<p>此外，你可以使用一个“通配符”星号来简化所有的假设和目标：</p>
<pre><code class="language-lean">attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w  * x)) : p (x * w * z + y * x) := by
  simp at *; assumption

example (x y z : Nat) (p : Nat → Prop)
        (h₁ : p (1 * x + y)) (h₂ : p  (x * z * 1))
        : p (y + 0 + x) ∧ p (z * x) := by
  simp at * &lt;;&gt; constructor &lt;;&gt; assumption
</code></pre>
<p>上例中前两行的意思是，对于具有交换律和结合律的运算（如自然数的加法和乘法），简化器使用这两个定律来重写表达式，同时还使用<em>左交换律</em>。在乘法的情况下，左交换律表达如下：<code>x * (y * z) = y * (x * z)</code>。<code>local</code>修饰符告诉简化器在当前文件（或小节或命名空间，视情况而定）中使用这些规则。交换律和左交换律是有一个问题是，重复应用其中一个会导致循环。但是简化器检测到了对其参数进行置换的特性，并使用了一种被称为<em>有序重写</em>的技术。这意味着系统保持着项的内部次序，只有在这样做会降低次序的情况下才会应用等式。对于上面提到的三个等式，其效果是表达式中的所有小括号都被结合到右边，并且表达式以一种规范的（尽管有些随意）方式排序。两个在交换律和结合律上等价的表达式然后被改写成相同的规范形式。</p>
<pre><code class="language-lean"># attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
# attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm
example (w x y z : Nat) (p : Nat → Prop)
        : x * y + z * w  * x = x * w * z + y * x := by
  simp

example (w x y z : Nat) (p : Nat → Prop)
        (h : p (x * y + z * w  * x)) : p (x * w * z + y * x) := by
  simp; simp at h; assumption
</code></pre>
<p>与<code>rewrite</code>一样，你可以向<code>simp</code>提供一个要使用的事实列表，包括一般引理、局部假设、要展开的定义和复合表达式。<code>simp</code>策略也能识别<code>rewrite</code>的<code>←t</code>语法。在任何情况下，额外的规则都会被添加到用于简化项的等式集合中。</p>
<pre><code class="language-lean">def f (m n : Nat) : Nat :=
  m + n + m

example {m n : Nat} (h : n = 1) (h' : 0 = m) : (f m n) = n := by
  simp [h, ←h', f]
</code></pre>
<p>一个常见的习惯是用局部假设来简化一个目标：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [h₁, h₂]
</code></pre>
<p>为了在简化时使用局部环境中存在的所有假设，我们可以使用通配符<code>*</code>：</p>
<pre><code class="language-lean">example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
  simp [*]
</code></pre>
<p>另一例：</p>
<pre><code class="language-lean">example (u w x y z : Nat) (h₁ : x = y + z) (h₂ : w = u + x)
        : w = z + y + u := by
  simp [*, Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]
</code></pre>
<p>简化器也会进行命题重写。例如，使用假设<code>p</code>，它把<code>p ∧ q</code>改写为<code>q</code>，把<code>p ∨ q</code>改写为<code>true</code>，然后以普通方式证明。迭代这样的重写，会生成非平凡的命题推理。</p>
<pre><code class="language-lean">example (p q : Prop) (hp : p) : p ∧ q ↔ q := by
  simp [*]

example (p q : Prop) (hp : p) : p ∨ q := by
  simp [*]

example (p q r : Prop) (hp : p) (hq : q) : p ∧ (q ∨ r) := by
  simp [*]
</code></pre>
<p>下一个例子简化了所有的假设，然后用这些假设来证明目标。</p>
<pre><code class="language-lean">example (u w x x' y y' z : Nat) (p : Nat → Prop)
        (h₁ : x + 0 = x') (h₂ : y + 0 = y')
        : x + y + 0 = x' + y' := by
  simp at *
  simp [*]
</code></pre>
<p>使得简化器特别有用的一点是，它的能力可以随着规则库的发展而增强。例如，假设我们定义了一个列表操作，该操作通过拼接其反转来对称其输入：</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
</code></pre>
<p>那么对于任何列表<code>xs</code>，<code>reverse (mk_symm xs)</code>等于<code>mk_symm xs</code>，这可以通过展开定义轻松证明：</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]
</code></pre>
<p>你可以使用这个定理来证明一些新结果：</p>
<pre><code class="language-lean">example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp [reverse_mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp [reverse_mk_symm] at h; assumption
</code></pre>
<p>但是使用<code>reverse_mk_symm</code>通常是正确的，如果用户不需要明确地调用它，那就更好了。你可以通过在定义该定理时将其标记为简化规则来实现这一点：</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<p>符号<code>@[simp]</code>宣布<code>reverse_mk_symm</code>具有<code>[simp]</code>属性，可以更明确地说明：</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<p>该属性也可以在定理声明后的任何时候应用：</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp[reverse_mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
</code></pre>
<p>然而，一旦属性被应用，就没有办法永久地删除它；它将在任何导入该属性的文件中持续存在。正如我们将在[属性]（未完成）一章中进一步讨论的那样，我们可以使用<code>local</code>修饰符将属性的范围限制在当前文件或章节中：</p>
<pre><code class="language-lean"># def mk_symm (xs : List α) :=
#  xs ++ xs.reverse
theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

section
attribute [local simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
end
</code></pre>
<p>在该部分之外，简化器将不再默认使用<code>reverse_mk_symm</code>。</p>
<p>请注意，我们讨论过的各种<code>simp</code>选项----给出一个明确的规则列表，并使用<code>at</code>指定位置----可以合并，但它们的排列顺序是严格的。你可以在编辑器中看到正确的顺序，把光标放在<code>simp</code>标识符上，查看与之相关的文档。</p>
<p>有两个额外的修饰符是有用的。默认情况下，<code>simp</code>包括所有被标记为<code>[simp]</code>属性的定理。写<code>simp only</code>排除了这些默认值，允许你使用一个更明确的规则列表。在下面的例子中，减号和<code>only</code>被用来阻止<code>reverse_mk_symm</code>的应用：</p>
<pre><code class="language-lean">def mk_symm (xs : List α) :=
  xs ++ xs.reverse
@[simp] theorem reverse_mk_symm (xs : List α)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp [-reverse_mk_symm] at h; assumption

example (xs ys : List Nat) (p : List Nat → Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp only [List.reverse_append] at h; assumption
</code></pre>
<h2 id="扩展策略"><a class="header" href="#扩展策略">扩展策略</a></h2>
<p>在下面的例子中，我们使用<code>syntax</code>命令定义符号<code>triv</code>。然后，我们使用<code>macro_rules</code>命令来指定使用<code>triv</code>时应该做什么。你可以提供不同的扩展，策略解释器将尝试所有的扩展，直到有一个成功。</p>
<pre><code class="language-lean">-- 定义一个新策略符号
syntax &quot;triv&quot; : tactic

macro_rules
  | `(tactic| triv) =&gt; `(tactic| assumption)

example (h : p) : p := by
  triv

-- 你不能用`triv`解决下面的定理：
-- example (x : α) : x = x := by
--  triv

-- 扩展`triv`。策略解释器会尝试所有可能的扩展宏，直到有一个成功。
macro_rules
  | `(tactic| triv) =&gt; `(tactic| rfl)

example (x : α) : x = x := by
  triv

example (x : α) (h : p) : x = x ∧ p := by
  apply And.intro &lt;;&gt; triv

-- 加一个递归扩展
macro_rules | `(tactic| triv) =&gt; `(tactic| apply And.intro &lt;;&gt; triv)

example (x : α) (h : p) : x = x ∧ p := by
  triv
</code></pre>
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<ol>
<li>
<p>用策略式证明重做<a href="./propositions_and_proofs.html">命题与证明</a>和<a href="./quantifiers_and_equality.html">量词与等价</a>两章的练习。适当使用<code>rw</code>和<code>simp</code>。</p>
</li>
<li>
<p>用策略组合子给下面的例子用一行写一个证明：</p>
</li>
</ol>
<pre><code class="language-lean"> example (p q r : Prop) (hp : p)
         : (p ∨ q ∨ r) ∧ (q ∨ p ∨ r) ∧ (q ∨ r ∨ p) := by
   admit
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="quantifiers_and_equality.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="interacting_with_lean.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="quantifiers_and_equality.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="interacting_with_lean.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
